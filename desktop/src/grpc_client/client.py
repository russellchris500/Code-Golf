"""gRPC client for connecting to backend relay server."""

import grpc
import logging
from typing import Iterator, Callable, Optional
import time
import uuid

# Import generated protobuf code
# These will be generated by protoc
import sys
sys.path.append('..')
# from proto import streaming_pb2, streaming_pb2_grpc

logger = logging.getLogger(__name__)


class GRPCClient:
    """gRPC client for streaming communication with backend."""

    def __init__(self, backend_url: str, user_id: str, use_tls: bool = False):
        """
        Initialize gRPC client.

        Args:
            backend_url: Backend server address (e.g., 'localhost:50051')
            user_id: User ID for pairing
            use_tls: Whether to use TLS encryption
        """
        self.backend_url = backend_url
        self.user_id = user_id
        self.use_tls = use_tls
        self.channel: Optional[grpc.Channel] = None
        self.stub = None
        self.stream = None
        self.connected = False

    def connect(self):
        """Establish connection to backend server."""
        logger.info(f"Connecting to backend at {self.backend_url}")

        if self.use_tls:
            credentials = grpc.ssl_channel_credentials()
            self.channel = grpc.secure_channel(self.backend_url, credentials)
        else:
            self.channel = grpc.insecure_channel(self.backend_url)

        # TODO: Uncomment when protobuf code is generated
        # self.stub = streaming_pb2_grpc.StreamingServiceStub(self.channel)

        logger.info("Connected to backend")
        self.connected = True

    def disconnect(self):
        """Close connection to backend server."""
        if self.stream:
            self.stream.cancel()
            self.stream = None

        if self.channel:
            self.channel.close()
            self.channel = None

        self.connected = False
        logger.info("Disconnected from backend")

    def start_stream(self, packet_handler: Callable):
        """
        Start bidirectional streaming.

        Args:
            packet_handler: Callback function to handle incoming packets
        """
        if not self.connected:
            raise RuntimeError("Not connected to backend")

        logger.info("Starting stream...")

        # TODO: Implement actual streaming when protobuf is generated
        # def packet_generator():
        #     # First packet: registration
        #     registration_packet = streaming_pb2.Packet(
        #         packet_id=str(uuid.uuid4()),
        #         user_id=self.user_id,
        #         source=streaming_pb2.DESKTOP,
        #         destination=streaming_pb2.MOBILE,
        #         type=streaming_pb2.CONTROL,
        #         timestamp=int(time.time() * 1000),
        #     )
        #     yield registration_packet
        #
        #     # Keep connection alive
        #     while self.connected:
        #         time.sleep(1)
        #
        # self.stream = self.stub.Stream(packet_generator())
        #
        # # Handle incoming packets
        # for packet in self.stream:
        #     packet_handler(packet)

        logger.info("Stream started")

    def send_packet(self, packet):
        """Send a packet to the backend."""
        # TODO: Implement when protobuf is generated
        pass

    def create_text_packet(self, text: str, text_type: str = "AI_RESPONSE"):
        """Create a text packet."""
        # TODO: Implement when protobuf is generated
        pass

    def create_audio_packet(self, audio_data: bytes, is_final: bool = False):
        """Create an audio packet."""
        # TODO: Implement when protobuf is generated
        pass

    def create_transcript_packet(self, text: str, is_final: bool = False, confidence: float = 1.0):
        """Create a transcript packet."""
        # TODO: Implement when protobuf is generated
        pass
